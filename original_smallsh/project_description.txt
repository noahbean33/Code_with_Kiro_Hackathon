# Programming Assignment 4: SMALLSH 

## Introduction
In this assignment you will write your own shell in C called **smallsh**. smallsh will implement a subset of features of well-known shells, such as bash. Your program will
* Provide a prompt for running commands
* Handle blank lines and comments, which are lines beginning with the `#` character
* Execute 3 commands **exit**, **cd**, and **status** via code built into the shell
* Execute other commands by creating new processes using a function from the `exec()` family of functions
* Support input and output redirection
* Support running commands in foreground and background processes
* Implement custom handlers for 2 signals, **SIGINT** and **SIGTSTP**

This is the "Portfolio Assignment" for the course. This means that you are allowed to post the entirety of the assignment publicly (e.g., GitHub, personal website, etc.) after the term ends. You can use this as an opportunity to showcase your work to potential employers.

## Learning Outcomes
After successful completion of this assignment, you should be able to do the following
* Describe the Linux process API (Module 6, MLO 2)
* Write programs using the Linux process API (Module 6, MLO 3)
* Explain the concept of signals and their uses (Module 6, MLO 2)
* Write programs using the Linux API for signal handling (Module 7, MLO 3)
* Explain I/O redirection and write programs that can employ I/O redirection (Module 7, MLO 4)

This assignment draws on the material from Module 6 and Module 7, in addition to earlier modules. You can use and adapt any code presented in the explorations in your solution.

## Program Functionality
Be sure to read the complete assignment. The "Hints and Resources" section has useful tips on implementing various items of program functionality.

### 1. The Command Prompt
Use the colon **:** symbol as a prompt for each command line. 
The general syntax of a command line is:
`command [arg1 arg2 ...] [< input_file] [> output_file] [&]`
where items in square brackets are optional.
* You can assume that a command is made up of words separated by spaces.
* The special symbols `<`, `>` and `&` are recognized, but they must be surrounded by spaces like other words.
* If the command is to be executed in the background, the last word must be `&`. If the `&` character appears anywhere else, just treat it as normal text.
* If standard input or output is to be redirected, the `>` or `<` words followed by a filename word must appear after all the arguments. Input redirection can appear before or after output redirection.
* Your shell does not need to support any quoting; so arguments with spaces inside them are not possible. We are also not implementing the pipe "|" operator.
* Your shell must support command lines with a maximum length of 2048 characters, and a maximum of 512 arguments.
* You do not need to do any error checking on the syntax of the command line.

### 2. Comments & Blank Lines
Your shell must allow blank lines and comments.
* Any line that begins with the `#` character is a comment line and must be ignored. Mid-line comments, such as the C-style //, will not be supported.
* A blank line (one without any commands) must also do nothing.
* Your shell must just re-prompt for another command when it receives either a blank line or a comment line.

### 3. Built-in Commands
Your shell will support three built-in commands: **exit**, **cd**, and **status**. These three built-in commands are the only ones that your shell will handle itself - all others are simply passed on to a member of the `exec()` family of functions.
* You do not have to support input/output redirection for these built in commands
* These commands do not have to set any exit status.
* If the user tries to run one of these built-in commands in the background with the & option, ignore that option and run the command in the foreground anyway (i.e. don't display an error, just run the command in the foreground).

#### exit
The `exit` command exits your shell. It takes no arguments. When this command is run, your shell must kill any other processes or jobs that your shell has started before it terminates itself.

#### cd
The `cd` command changes the working directory of smallsh.
* By itself - with no arguments - it changes to the directory specified in the HOME environment variableThis is typically not the location where smallsh was executed from, unless your shell executable is located in the HOME directory, in which case these are the same.
* This command can also take one argument: the path of a directory to change to. Your `cd` command must support both absolute and relative paths.

#### status
The `status` command prints out either the exit status or the terminating signal of the last foreground process ran by your shell.
* If this command is run before any foreground command is run, then it must simply return the exit status 0.
* The three built-in shell commands do not count as foreground processes for the purposes of this built-in command - i.e., **status** must ignore built-in commands.

### 4. Executing Other Commands
Your shell will execute any commands other than the 3 built-in command by using `fork()`, `exec()` and `waitpid()`
* Whenever a non-built in command is received, the parent (i.e., smallsh) will fork off a child.
* The child will use a function from the `exec()` family of functions to run the command.
* Your shell must use the PATH variable to look for non-built in commands, and it must allow shell scripts to be executed.
* If a command fails because the shell could not find the command to run, then the shell will print an error message and set the exit status to 1
* A child process must terminate after running a command (whether the command is successful or it fails).

### 5. Input & Output Redirection
You must do any input and/or output redirection using `dup2()`. The redirection must be done before using `exec()` to run the command.
* An input file redirected via `stdin` must be opened for reading only; if your shell cannot open the file for reading, it must print an error message and set the exit status to 1 (but don't exit the shell).
* Similarly, an output file redirected via `stdout` must be opened for writing only; it must be truncated if it already exists or created if it does not exist. If your shell cannot open the output file, it must print an error message and set the exit status to 1 (but don't exit the shell).
* Both `stdin` and `stdout` for a command can be redirected at the same time (see example below).

### 6. Executing Commands in Foreground & Background
#### Foreground Commands
Any command without an `&` at the end must be run as a foreground command and the shell must wait for the completion of the command before prompting for the next command. For such commands, the parent shell does NOT return command line access and control to the user until the child terminates.
#### Background Commands
Any non built-in command with an `&` at the end must be run as a background command and the shell must not wait for such a command to complete. For such commands, the parent must return command line access and control to the user immediately after forking off the child.
* The shell will print the process id of a background process when it begins.
* When a background process terminates, a message showing the process id and exit status will be printed. This message must be printed just before the prompt for a new command is displayed.
* If the user doesn't redirect the standard input for a background command, then standard input must be redirected to `/dev/null`.
* If the user doesn't redirect the standard output for a background command, then standard output must be redirected to `/dev/null`.

### 7. Signals SIGINT & SIGTSTP
#### SIGINT
* A `CTRL-C` command from the keyboard sends a `SIGINT` signal to the parent process and all children at the same time (this is a built-in part of Linux).
* Your shell, i.e., the parent process, must ignore `SIGINT`.
* Any children running as background processes must ignore `SIGINT`.
* A child running as a foreground process must terminate itself when it receives `SIGINT`.The parent must not attempt to terminate the foreground child process; instead the foreground child (if any) must terminate itself on receipt of this signal.
* If a child foreground process is killed by a signal, the parent must immediately print out the number of the signal that killed it's foreground child process (see the example) before prompting the user for the next command.

#### SIGTSTP
* A `CTRL-Z` command from the keyboard sends a `SIGTSTP` signal to your parent shell process and all children at the same time (this is a built-in part of Linux).
* A child, if any, running as a foreground process must ignore `SIGTSTP`.
* Any children running as background process must ignore `SIGTSTP`.
* When the parent process running the shell receives `SIGTSTP`
    * The shell must display an informative message (see below) immediately if it's sitting at the prompt, or immediately after any currently running foreground process has terminated
    * The shell then enters a state where subsequent commands can no longer be run in the background.
    * In this state, the `&` operator must simply be ignored, i.e., all such commands are run as if they were foreground processes.
* If the user sends `SIGTSTP` again, then your shell will
    * Display another informative message (see below) immediately after any currently running foreground process terminates
    * The shell then returns back to the normal condition where the & operator is once again honored for subsequent commands, allowing them to be executed in the background.
* See the example below for usage and the exact syntax which you must use for these two informative messages.

## Sample Program Execution
Here is an example run using smallsh. Note that **CTRL-C** has no effect towards the bottom of the example, when it's used while sitting at the command prompt:
$ smallsh
: ls
junk   smallsh    smallsh.c
: ls > junk
: status
exit value 0
: cat junk
junk
smallsh
smallsh.c
: wc < junk > junk2
: wc < junk
3       3      23
: test -f badfile
: status
exit value 1
: wc < badfile
cannot open badfile for input
: status
exit value 1
: badfile
badfile: no such file or directory
: sleep 5
^Cterminated by signal 2
: status &
terminated by signal 2
: sleep 15 &
background pid is 4923
: ps
PID TTY          TIME CMD
4923 pts/0    00:00:00 sleep
4564 pts/0    00:00:03 bash
4867 pts/0    00:01:32 smallsh
4927 pts/0    00:00:00 ps
:
: # that was a blank command line, this is a comment line
:
background pid 4923 is done: exit value 0
: # the background sleep finally finished
: sleep 30 &
background pid is 4941
: kill -15 4941
background pid 4941 is done: terminated by signal 15
: pwd
/nfs/stak/users/chaudhrn/CS344/prog3
: cd
: pwd
/nfs/stak/users/chaudhrn
: cd CS344
: pwd
/nfs/stak/users/chaudhrn/CS344
: echo 4867
4867
: ^C^Z
Entering foreground-only mode (& is now ignored)
: date
Mon Jan  2 11:24:33 PST 2017
: sleep 5 &
: date
Mon Jan  2 11:24:38 PST 2017
: ^Z
Exiting foreground-only mode
: date
Mon Jan  2 11:24:39 PST 2017
: sleep 5 &
background pid is 4963
: date
Mon Jan 2 11:24:39 PST 2017
: exit
$


## Hints & Resources
Here is a [sample parser](https://oregonstate.instructure.com/courses/1986423/files/100418349/download?wrap=1) that you are free to adapt for your solution (use of this code is **not** required).

### 1. The Command Prompt
Be sure you flush out the output buffers each time you print, as the text that you're outputting may not reach the screen until you do in this kind of interactive program. To do this, call `fflush()` immediately after each and every time you output text.

### 2. Comments & Blank Lines
This should be simple.

### 3. Built-in Commands
It is recommended that you program the built-in commands first, before tackling the commands that require `fork()`, `exec()` and `waitpid()`.
The built-in commands don't set the value of status. This means that however you are keeping track of the status, don't change it after the execution of a built-in command.

### 4. Executing Other Commands
Note that if `exec()` is told to execute something that it cannot do, like run a program that doesn't exist, it will fail, and return the reason why. In this case, your shell must indicate to the user that a command could not be executed (which you know because `exec()` returned an error), and set the value retrieved by the built-in **status** command to 1.
Make sure that the child process that has had an `exec()` call fail terminates itself, or else it often loops back up to the top and tries to become a parent shell.
You can choose any function in the `exec()` family. However, we suggest that using either `execlp()` or `execvp()` will be simplest because of the following reasons
* smallsh doesn't need to pass a new environment to the program. So the additional functionality provided by the `exec()` functions with names ending in e is not required.
* One example of a command that smallsh needs to run is **ls**. Running this command will be a lot easier using the `exec()` functions that search the **PATH** environment variable.

### 5. Input & Output Redirection
We recommend that the needed input/output redirection should be done in the child process.
Note that after using `dup2()` to set up the redirection, the redirection symbol and redirection destination/source are NOT passed into the exec command
For example, if the command given is `ls > junk`, then you handle the redirection to "junk" with `dup2()` and then simply pass **ls** into `exec()`.

### 6. Executing Commands in Foreground & Background
#### Foreground Commands
For a foreground command, it is recommend to have the parent simply call `waitpid()` on the child, while it waits.
#### Background Commands
The shell must respect the input and output redirection operators for a command regardless of whether the command is to be run in the foreground or the background.
* This means that a background command must use `/dev/null` for input only when input redirection is not specified in the command.
* Similarly a background command must use `/dev/null` for output only when output redirection is not specified in the command.
* Your parent shell will need to periodically check for the background child processes to complete, so that they can be cleaned up, as the shell continues to run and process commands. 
* Consider storing the PIDs of non-completed background processes in an array. Then every time BEFORE returning access to the command line to the user, you can check the status of these processes using `waitpid(...WNOHANG...)`.
* Alternatively, you may use a signal handler to immediately `wait()` for child processes that terminate, as opposed to periodically checking a list of started background processes
* The time to print out when these background processes have completed is just BEFORE command line access and control are returned to the user, every time that happens.

### 7. Signals SIGINT & SIGTSTP
Reentrancy is important when we consider that signal handlers cause jumps in execution that cause problems with certain functions. Note that the `printf()` family of functions is NOT reentrant. In your signal handlers, when outputting text, you must use other output functions!

## What to turn in?
Your assignment will be graded using Gradescope.
* If your program contains multiple files, then submit a single zip file with all your code.This zip file must be named **youronid_assignment4.zip** where youronid must be replaced by your own ONID.
* E.g., if `chaudhrn` was submitting the assignment, the file must be named `chaudhrn_assignment4.zip`.
* All the code files must be at the root level of the zip file, i.e., the files must not be in sub-folders.
* Our script will unzip your zip file and then create an executable file by running the following command in the root directory which was created by unzipping the file
`gcc --std=gnu99 -o smallsh *.c`
* If all the code for your program is in just one `.c` file, you can either just submit that one `.c` file or submit a zip file containing that `.c` file.If you are submitting a single `.c` file, the file must be named **youronid_assignment4.c** where `youronid` must be replaced by your own ONID.
* Our script will create an executable file by running the following command in a directory which contains only your `.c` file.
`gcc --std=gnu99 -o smallsh *.c`
* Your zip file must not contain any extraneous files. For example, make sure not to zip up the `__MACOSX` directories.

## Caution
If you decide to develop using an EECS server, take extra care to do your work **only on os1**, our class server, as your software will likely negatively impact whatever machine it runs on. If you cause trouble on one of the non-class, public servers, it could hurt your grade! If you are having trouble logging in to an EECS servers because of runaway processes, please use this page to kill off any programs running on your account that might be blocking your access:
[T.E.A.C.H. - The Engineering Accounts and Classes Homepage](https://oregonstate.edu/teach/tools/manage/kill-processes)

## Grading Criteria
This assignment is worth 20% of your final grade.
The grading will be done using Gradescope. There is no Canvas rubric for this assignment. For total points and break-up of points, see Gradescope.